[ ][ ][ ][ ][ ][ ]
[ ][ ][ ][ ][ ][ ]
[ ][ ][ ][i][ ][ ]			P( leak in i )
[ ][ ][ ][ ][ ][ ]			P( leak is not in i ) = 1 - P( leak in i )
[ ][j][ ][ ][ ][ ]
[ ][ ][ ][ ][ ][ ]

Prob. Knowledge Base:

    Bot is d-steps away from the leak (shortest path through the ship), the probability of receiving a beep is e^(-a*(d-1)),

    P( leak is in cell j ) for each open cell j
    
    For the cell i the bot is in 
    
        P( leak is in cell i ) = 0
    
    For every other cell j
    
        P( leak is in cell j ) = 1 / (# open cells - 1)
        
At any time t:
    We have that time, bot is located at location bot_t <- cell the bot is in at time t


    We can do two things:
    
        - Bot 'listens' for a beep (or a not-beep)
        
            Bot senses and collects DATA in cell i
            
                - DATA = Beep
                
                    P( leak is in cell i | we heard a beep while in cell i ) = 0
                    P( leak is in cell j | we heard a beep while in cell i ) for j != i
                    
                    P( leak is in cell j | we heard a beep while in cell i )
                    
                        = P( leak is in cell j AND beep in cell i ) / P( beep in cell i )
                        
                        = P( leak in cell j ) * P( beep in cell i | leak in cell j ) / P( beep in cell i )
                        
                        = P( leak in cell j ) * e^(-a*(d(i,j)-1)) / P( beep in cell i )
                        
                        = P( leak in cell j ) * e^(-a*(d(i,j)-1)) / [ sum_k P( leak in k ) *  e^(-a*(d(i,k)-1)) ]
                        
                        
                                P( beep in cell i ) = sum_k P( leak in k AND beep in cell i )
                                
                                = sum_k P( leak in k ) * P( beep in i | leak in k )
                                
                                = sum_k P( leak in k ) *  e^(-a*(d(i,k)-1))
                
                - DATA = No Beep
                
                    Currently:
                    
                        P( leak is in cell k ) for each cell k
                
                    New Probabilities:
                        For cell i (our current cell): P( leak is in cell i | we heard no beep while in cell i ) = 0
                        For cell j != i : P( leak is in cell j | we heard no beep while in cell i )
                                            = P( leak in cell j ) * ( 1 - e^(-a*(d(i,j)-1)) ) / [ sum_k P( leak is in k ) * ( 1 - e^(-a*(d(i,k)-1)) ) ]
                    
                    
                        
        
        
        - Bot can move to another cell
        
            Bot moves from cell bot_t to cell i
            
                - Bot finds the leak in cell i
                
                    UPDATE
                        Current P( leak is in cell k ) for each cell k
                    
                        New Probabilities:
                
                            For cell i: P( leak in cell i | bot finds the leak in cell i ) = 1
                            For cell j != i: P( leak in cell j | bot finds the leak in cell i ) = 0
                
                - Bot does not find the leak in cell i
                    
                    UPDATE:
                        Current P( leak is in cell k ) for each cell k
                        
                        New Probabilities:
                        
                            For cell i: P( leak is in cell i | bot doesn't find leak in i ) = 0
                            For cell j != i: P( leak is in cell j | bot doesn't find leak in i )
                                                = P( leak is in cell j ) * 1 / (1 - P( leak is in i ))
                    
                        
    
    P( A and B ) = P( A ) * P( B | A )
    
    
    Conditional Probability
    
        P( A | B ) = P( A and B ) / P( B )
        
            -> P( A and B ) = P( B ) * P( A | B )
            -> P( A and B ) = P( A ) * P( B | A )
    


    
    P( leak is in cell i | bot doesn't find leak in i ) = 0
    P( leak is in cell j | bot doesn't find leak in i ) for each j != i
        
    = P( leak is in cell j AND bot doesn't find leak in i ) / P( bot doesn't find leak in i )
        
    = P( leak is in cell j ) * P( bot doesn't find leak in i | leak is in cell j) / P( bot doesn't find leak in i )
    
    = P( leak is in cell j ) * 1 / P( leak is not in i )
    
    = P( leak is in cell j ) * 1 / (1 - P( leak is in i ))
    
    
    
    
    P( leak is in cell j | we heard no beep while in cell i ) for j != i
    
        = P( leak in cell j AND no beep in cell i ) / P( no beep in cell i )
        
        = P( leak in cell j ) * P( no beep in cell i | leak in cell j ) / P( no beep in cell i )
        
        = P( leak in cell j ) * ( 1 - e^(-a*(d(i,j)-1)) ) / P( no beep in cell i )
        
        = P( leak in cell j ) * ( 1 - e^(-a*(d(i,j)-1)) ) / [ sum_k P( leak is in k ) * ( 1 - e^(-a*(d(i,k)-1)) ) ]


    P( no beep in cell i ) = sum_k P( leak is in k AND no beep in cell i ) <- marginalization
    
    = sum_k P( leak is in k ) * P( no beep in cell i | leak is in k )
    
    = sum_k P( leak is in k ) * ( 1 - e^(-a*(d(i,k)-1)) )
                
                
                
                
                
                
                
            SHIP = [ each cell labeled POSSIBLE ]
            
            bot position = initial position
            
            SHIP[ bot position ] = FALSE
            
            total actions = 0
            
            LOOP UNTIL BOT POSITION == LEAK POSITION:
            
                run detection square on BOT POSITION
                total actions += 1
                    
                if detection = POSITIVE:
                    SHIP[ cell ] = FALSE for each cell OUTSIDE detection square
                    
                if detection = NEGATIVE:
                    SHIP[ cell ] = FALSE for each cell in detection square
                    
                next position = cell nearest BOT POSITION s.t. SHIP[ cell ] = POSSIBLE
                
                move BOT POSITION to next position
                total actions += distance( BOT POSITION, next position )
        
            return total actions
                
                
                
                
                
                
                
                
                
            At at any time t:
            
                    next position = cell j that has highest P( leak is in cell j )
                    
                    
                    plan path ( bot position, next position )
                    
                    
                    
        
        Enter cell i, don't find the leak
        
            P( leak is in cell i | you didn't find it in cell i ) = 0
            
            P( leak is in cell j | you didn't find it in cell i ) = P( leak in cell j ) / ( 1 - P( leak in cell i ) )
                

-- New Findings --
Suppose you have five cells, a b c d, e

P(leak in a) = 0.4
P(leak in b) = 0.2
P(leak in c) = 0.1
P(leak in d) = 0.3
P(leak in e) = 0.0

You are currently in cell e

You move to cell d
You do not find the leak

What are P(leak in a | leak not in d), etc, for each cell?

What are the new probabilities?

P( leak in a | leak not in d )
   = P( leak in a and leak not in d ) / P( leak not in d )
   = P( leak in a ) * P( leak not in d | leak in a ) / P( leak not in d)
   = ( P( leak in a ) * 1 ) / P( leak not in d )
   = P( leak in a ) / ( 1 - P ( leak is in d ) )
   = 0.4 / ( 1 - 0.3 ) = 0.4 / 0.7 = 0.57

P( leak in b | leak not in d )
   = P( leak in b and leak not in d ) / P( leak not in d )
   = P( leak in b ) * P( leak not in d | leak in b ) / P( leak not in d)
   = ( P( leak in b ) * 1 ) / P( leak not in d )
   = P( leak in b ) / ( 1 - P ( leak is in d ) )
   = 0.2 / 0.7 = 0.28

P( leak in c | leak not in d )
   = P( leak in c and leak not in d ) / P( leak not in d )
   = P( leak in c ) * P( leak not in d | leak in c ) / P( leak not in d)
   = ( P( leak in c ) * 1 ) / P( leak not in d )
   = P( leak in c ) / ( 1 - P ( leak is in d ) )
   = 0.1 / 0.7 = 0.14

P( leak in d | leak not in d ) = 0

P( leak in e | leak not in d )
   = P( leak in e and leak not in d ) / P( leak not in d )
   = P( leak in e ) * P( leak not in d | leak in e ) / P( leak not in d)
   = ( P( leak in e ) * 1 ) / P( leak not in d )
   = P( leak in e ) / ( 1 - P ( leak is in d ) )
   = 0 / 0.7 = 0

New probabilities
P(leak in a) = 0.57
P(leak in b) = 0.28
P(leak in c) = 0.14
P(leak in d) = 0.0
P(leak in e) = 0.0


-- Seed Example Walkthrough --

KB:
-1     , 0.125  , -1     , -1     , -1     
-1     , 0.125  , -1     , -1     , -1     
0.125  , 0.125  , 0.125  , 0.125  , BOT    
-1     , 0.125  , -1     , -1     , -1     
-1     , 0.125  , -1     , -1     , -1

P( leak in (2, 4) ) = 0
P( leak in (2, 3) ) = 0.125
P( leak in (2, 2) ) = 0.125
P( leak in (2, 1) ) = 0.125
P( leak in (2, 0) ) = 0.125
P( leak in (1, 1) ) = 0.125
P( leak in (0, 1) ) = 0.125
P( leak in (3, 1) ) = 0.125
P( leak in (4, 1) ) = 0.125

T = 0 -> BEEP!

P( leak in (2, 4) | we heard a beep in (2, 4) ) = 0

P( leak in (2, 3) | we heard a beep in (2, 4) )
    = P( leak is in cell (2, 3) AND beep in cell (2, 4) ) / P( beep in cell (2, 4) )
    = P( leak in cell (2, 3) ) * P( beep in cell (2, 4) | leak in cell (2, 3) ) / P( beep in cell (2, 4) )
    = P( leak in cell (2, 3) ) * e^(-a*(d((2, 4),(2, 3))-1)) / P( beep in cell (2, 4) )
    = P( leak in cell (2, 3) ) * e^(-a*(d((2, 4),(2, 3))-1)) / [ sum_k P( leak in k ) *  e^(-a*(d((2, 4),k)-1)) ]
    = 0.125 * e^(-a * 1 - 1) / [ sum_k P( leak in k ) *  e^(-a*(d((2, 4),k)-1)) ]

        [ sum_k P( leak in k ) *  e^(-a*(d((2, 4),k) - 1)) ] =
            0.125 * e^(-a*(d( (2, 4), (2, 4) ) - 1)) +
            0.125 * e^(-a*(d( (2, 4), (2, 3) ) - 1)) +
            0.125 * e^(-a*(d( (2, 4), (2, 2) ) - 1)) + 
            0.125 * e^(-a*(d( (2, 4), (2, 1) ) - 1)) + 
            0.125 * e^(-a*(d( (2, 4), (2, 0) ) - 1)) + 
            0.125 * e^(-a*(d( (2, 4), (1, 1) ) - 1)) + 
            0.125 * e^(-a*(d( (2, 4), (0, 1) ) - 1)) + 
            0.125 * e^(-a*(d( (2, 4), (3, 1) ) - 1)) + 
            0.125 * e^(-a*(d( (2, 4), (4, 1) ) - 1)) =
            
            0.125 * e^(-a*(0 - 1)) +
            0.125 * e^(-a*( 1 - 1 )) +
            0.125 * e^(-a*( 2 - 1)) + 
            0.125 * e^(-a*( 3 - 1 )) + 
            0.125 * e^(-a*( 4 - 1 )) + 
            0.125 * e^(-a*( 4 - 1 )) + 
            0.125 * e^(-a*( 5 - 1 )) + 
            0.125 * e^(-a*( 4 - 1 )) + 
            0.125 * e^(-a*( 5 - 1 )) =

            let a = 1 =>

0.125 * e^(-1( -1 )) +
0.125 * e^(-1( 0 )) +
0.125 * e^(-1( 1)) + 
0.125 * e^(-1( 2 )) + 
0.125 * e^(-1( 3 )) + 
0.125 * e^(-1( 3 )) + 
0.125 * e^(-1( 4 )) + 
0.125 * e^(-1( 3 )) + 
0.125 * e^(-1( 4 )) =

            0.5509361295

        = 0.125 * e^(-a * (1 - 1)) / 0.5509361295
        = 0.125 * 1 / 0.5509361295 = 0.12527175



    
